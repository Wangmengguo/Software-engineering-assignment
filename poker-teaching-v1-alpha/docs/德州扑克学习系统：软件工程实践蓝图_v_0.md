# 德州扑克学习系统：软件工程实践蓝图 v0.4

> 目标：把“学习软件工程实践”“搭一个可用的全栈项目”“沉淀成可学的课程文档”三件事合并为一条主线，用项目驱动学习，用工程化产物证明学习成效。

---

## 1) 愿景与终局（Definition of Success）

- **学习成果**：能独立说明并应用需求分析、架构设计、版本管理、测试、CI/CD、可观测性、性能与安全的基础方法；具备把想法落成在线服务的能力。
- **产品成果**：发布一个可在线访问的「德州扑克学习系统（Teaching‑First）」，包含：
  - 单人训练/牌桌回放/动作建议；
  - 局后复盘（牌谱、期望值、常见错误库）；
  - 教学视图（最小可用）。
- **文档成果**：形成一份“课程手记”（可公开）：章节化整理我们每周对话、决策、踩坑与复盘，便于后来者复用。

**度量**（可验证）：

- 至少 10+ 次迭代，每次迭代都有可演示的可视化改动（界面或指标看板）。
- 测试覆盖率≥60%（核心域）与端到端用例 ≥8 条；
- CI 全绿 + 一键部署（主干受保护）；
- 文档站点可访问，章节完整。

---

## 2) 项目定位与受众

- **学习导向**优先于娱乐性：界面极简、信息密度高、教学解释直白。
- **单人对战为主**，多人实时作为扩展层（避免一上来陷入高复杂度）。

---

## 3) 范围与阶段（Scope & Phasing）

- **MVP（Stage A）**：本地/单人训练 + 手牌回放 + 基本评估（无实时通信）。
- **Stage B**：内置机器人对局 + 策略建议（规则引擎/现有库）。
- **Stage C**：多人实时/观战（WebSocket）+ 房间/牌局同步。
- **Stage D（选做）**：策略讲解（可插拔 AI 讲解模块、知识库）。

> 原则：每个阶段结束，都能“看得见”的价值（界面/图表/日志/报告）。

---

## 4) 架构草图（Django‑First，迁栈友好）

```
[Web(早期)] Django(模板/管理后台) ──▶ [DRF API + OpenAPI]
         │                                   │
         │(逐步引入 Next.js 前端)             │
         ▼                                   ▼
[Next.js 前端(后续)]                     [领域包 poker_core]
                                            │
                                            ▼
                                      [PostgreSQL]
                                            │
                                            ▼
                                   [Redis/Channels]
                                            │
                                            ▼
                                   [Observability]
```

- **核心原则**：API‑First、领域解耦（业务逻辑在 `poker_core` 包；视图/ORM 只做编排）、契约先行（OpenAPI/JSON Schema）。
- **鉴权**：JWT（RS256），Django 颁发（simplejwt），前端用 HttpOnly Cookie；公钥可被后续 FastAPI/Next 侧验证。
- **实时**：Stage C 再引入 **Django Channels + Redis**；消息体带 `version` 字段，便于将来替换为 FastAPI/WebSocket 服务。
- **部署**：本地 Docker Compose；线上首选 Render/Zeabur（开发体验优先），可平滑迁移 Cloud Run/Fly（生产化）。

---

## 5) 技术选型备选矩阵（简）

| 维度  | 方案A（**默认**）                                | 方案B                  | 方案C             | 选择依据                        |
| --- | ------------------------------------------ | -------------------- | --------------- | --------------------------- |
| 前端  | Django 模板（早期）→ 渐进引入 **Next.js**            | 纯 Next.js 起步         | 仅 Django 模板     | A：最平缓且易迁栈；B：前端能力强；C：最快但扩展性弱 |
| 后端  | **Django + DRF**                           | FastAPI（后续 v2 API）   | Django（不暴露 API） | DRF 便于契约与迁移；FastAPI 作为增长路线  |
| 规则  | **PokerKit + 关键自研(poker\_core)**           | 全自研                  | 全外部库            | 混合方案上手快且可教学                 |
| 实时  | **Channels + Redis（后置）**                   | FastAPI WS/Socket.IO | 关闭              | A：足够 + 易迁；B：生态丰富            |
| 数据库 | **PostgreSQL**                             | —                    | —               | 通用、稳健、可迁移                   |
| 托管  | **Render/Zeabur**（开发）→ Cloud Run/Fly（生产可选） | —                    | —               | 开发体验 vs 生产化                 |

\------------------ | ----------------- | --------------------- | | 前端 | Next.js + Tailwind | Vite + React      | 文档/教学/SSR 友好 vs 纯前端简单 | | 后端 | FastAPI            | Django/NestJS     | 学习曲线/生态/文档完整度         | | 规则 | PokerKit/极简自研      | 纯自研               | 速度上手 vs 深入理解          | | 实时 | FastAPI WS         | Socket.IO/SignalR | 简洁 vs 生态工具            | | 托管 | Fly/Render/Zeabur  | Cloud Run         | 价格/冷启动/易用性            |

---

## 6) 可视化学习与“可见的进步”

- 每周在 UI 上 **显式展示**：新增按钮/图表/面板/对局回放。
- 加一个 **学习仪表盘**：
  - 研发指标：构建时间、测试数、覆盖率、端到端通过数；
  - 产品指标：活跃训练场次、复盘点击、平均回合时长、常见错误 TopN。
- 日志时间线：记录每一次“工程化改造”的效果（前后对比）。

---

## 7) 工程实践主题地图（学习大纲，不等于每周任务）

1. 需求澄清与用户故事（Teaching‑First 的准则）
2. 领域建模（牌桌/玩家/操作/状态机/回放）与边界划分
3. Git 分支策略、语义化提交、PR 模板、Code Review
4. 测试金字塔：单测/集成/端到端；TDD 与“学习用 Spike”
5. 持续集成（CI）与一键部署；环境管理/配置分离
6. 观察性：结构化日志、指标、追踪；调试与压测入门
7. 实时系统基础（WebSocket/状态同步/幂等性/断线重连）
8. 数据建模与迁移；性能与索引；快照与回放
9. 安全基础（鉴权、速率限制、输入校验、常见漏洞）
10. 文档工程（MkDocs/Docusaurus）、ADR 决策记录与变更日志
11. UI/UX for Teaching：极简视觉、动画与可用性、可访问性
12. 生产化与运维：监控告警、错误收集、回滚策略

---

## 8) 章节骨架（课程手记的目录雏形）

- 序章：为什么是“Teaching‑First”的德州扑克
- Ch1：从问题到产品愿景（需求、范围、成功标准）
- Ch2：最小架构与域模型（含首个可运行 Demo）
- Ch3：测试金字塔与工程化质量
- Ch4：数据层与迁移
- Ch5：对局回放与教学视图
- Ch6：机器人与策略接口
- Ch7：实时房间与状态同步
- Ch8：可观测性与性能
- Ch9：安全与上线
- Ch10：发布与运营、课程沉淀与复盘

> 每章结尾：术语表/清单/踩坑集/复盘问答。

---

## 9) 风险与矛盾点（以及缓解）

- **学习者起点 vs 项目复杂度**：以 **Stage A → B → C** 逐级递增；每级都能独立成品。
- **教学优先 vs 实时复杂度**：先做离线/单人复盘，把教学价值做扎实，再引入实时。
- **范围失控（Feature Creep）**：每迭代限定 1\~2 个可演示目标，其他进入待办池。
- **第三方库依赖/许可证**：优先选宽松许可证；高耦合处保留“自研降级”方案。
- **时间预算**：以“可视化产出”为节拍，避免长时间“隐形进度”。

---

## 10) 评估与验收（Learning Proof）

- **演示清单**：每次迭代录屏/动图 + 改动说明。
- **质量门槛**：测试/覆盖/静态检查必须过；主干受保护。
- **学习问答**：每章提供 5\~8 个“理解核对题”，用于自测。

---

## 11) 文档与知识沉淀

- **形式**：Docusaurus/MkDocs 文档站（托管与项目同源），章节与对话同步整理。
- **ADR（Architecture Decision Record）**：重要技术选择都写进 /docs/adr/。
- **开放性**：示例代码、图表、脚本全部可复用。

---

## 12) 全局决策（v0.2 已定）

0. **可视化迭代原则**：每次迭代必须产出“看得见”的变化（UI/指标/文档或录屏），纳入验收门并在仪表盘体现。
1. **技术栈**：Django + DRF + PostgreSQL（默认）；Stage C 引入 Channels + Redis；允许后续并行接入 Next.js 与 FastAPI。
2. **范围层级**：A（单人训练/回放/复盘）→ B（机器人/策略接口）→ C（实时房间与观战）。每层都能独立演示与验收。
3. **规则引擎**：**库 + 关键自研** 的混合路线，**以教学透明为优先**；起步接入 PokerKit，关键环节自研为独立包 `packages/poker_core`。
4. **鉴权与契约**：JWT（RS256，simplejwt 颁发，HttpOnly Cookie）；API 契约以 OpenAPI（drf‑spectacular）与 JSON Schema 为准。
5. **托管策略**：坚持 **易用 × 可控 的平衡**——开发期优先 Render/Zeabur；生产期可迁 Cloud Run/Fly；评估维度包含冷启动、观测能力、回滚与成本。
6. **视觉语言**：**极简、低饱和度、高信息密度 + 微动效** 作为统一设计公约。

---

## 12.1 视觉语言：KPI「药丸」组件规范（v0.4.1）

> 目的：统一数字类关键指标的展示样式，保证信息密度、响应式与微动效一致；适用于首页指标/教学面板/运营看板。

### A) 结构（HTML 最小骨架）

```html
<div class="kpi">
  <div class="pill">
    <span class="label">Session deals</span>
    <span class="value" id="session_deals">0</span>
  </div>
  <div class="pill">
    <span class="label">Replays total</span>
    <span class="value" id="db_replays_total">0</span>
  </div>
  <div class="pill">
    <span class="label">Last latency (ms)</span>
    <span class="value" id="lat">–</span>
  </div>
  <div class="pill">
    <span class="label">Errors</span>
    <span class="value" id="errs">0</span>
  </div>
</div>
```

### B) 样式（CSS 变量与响应式）

```css
.kpi{display:grid;grid-template-columns:repeat(auto-fit,minmax(180px,1fr));gap:12px;margin-top:8px}
.kpi .pill{background:#0d0d0d;border:1px solid #1f1f1f;padding:10px 12px;border-radius:10px}
.kpi .label{display:block;font-size:12px;color:#9aa0a6;margin-bottom:4px;letter-spacing:.2px}
.kpi .value{font-size:18px;font-weight:600}
.pulse{animation:pulse .3s ease}
@keyframes pulse{0%{transform:scale(1)}50%{transform:scale(1.02)}100%{transform:scale(1)}}
```

### C) 行为（更新与动效）

```js
function upd(id,val){const el=document.getElementById(id);const nv=(val??'-').toString();if(el&&el.textContent!==nv){el.textContent=nv;el.classList.add('pulse');setTimeout(()=>el.classList.remove('pulse'),300);}}
```

- **更新频率**：默认 5s；重要操作（如 Deal）后立即刷新一次。
- **可见性优化**：使用 Page Visibility 在标签页隐藏时暂停更新。

### D) 可访问性（A11y）

- 为关键数值添加 `aria-live="polite"`；标签使用语义化文本。
- 颜色对比 ≥ 4.5:1；仅以颜色区分状态时需辅以图标/文字。

### E) Do / Don’t

- **Do**：统一字号层级（label 12 / value 18）、统一边距与圆角；自动换行网格。
- **Don’t**：在同一屏里混用不同风格的数值块；用跳动的大动画打断阅读；把长文本塞进药丸。

---

## 13) Django‑First 迁栈绿道（v0.2 指导）

Django‑First 迁栈绿道（v0.2 指导）

### Phase 0（从今天开始就这样做）

- **API‑First**：所有功能以 DRF 暴露；用 **drf‑spectacular** 生成 OpenAPI；在 `/packages/shared_contracts` 存放 JSON Schemas。
- **领域解耦**：业务逻辑在 `packages/poker_core`（纯 Python，不依赖 Django），视图/模型只做编排与持久化。
- **数据层**：PostgreSQL 为单一真源；统一主键/时间戳；复杂查询写 **Repository/Service** 层，避免堆在 View/Model/Signal。
- **鉴权**：JWT（RS256），Django 签发；前端使用 HttpOnly Cookie；将来任何服务用公钥即可验证。
- **实时预留**：消息体带 `version`（例如 `v:1`）；未来 FastAPI/WS 可直接复用消息格式。
- **工程化**：pytest + factory‑boy、coverage ≥60%（核心域）；pre‑commit（ruff/black/isort/mypy）；GitHub Actions（lint/测试/构建）。
- **可观测性**：结构化日志、基础指标（请求量/错误率/延迟/对局数/复盘点击/Top 错误）。
- **文档**：Docusaurus/MkDocs；ADR 记录重大取舍；每章模板含术语表/清单/踩坑集/自测题。
- **目录骨架**：

```
/apps
  /web-django          # DRF + 管理后台 + 早期模板
  /next-web            # Next.js 前端（后加）
  /api-fastapi         # v2 API（后加）
/packages
  /poker_core          # 纯 Python 领域包
  /shared_contracts    # OpenAPI/JSON Schemas/事件枚举
/infra
  docker-compose.yml   # db/redis/web/proxy
  nginx.conf           # /api/v1 -> django, /api/v2 -> fastapi, / -> next
```

- **避免红线**：
  - 业务逻辑落在 Model/Signal；
  - 视图拼接 ORM 细节不可复用；
  - 前端依赖 Django 模板变量；
  - 事件无版本号。

### Phase 1（引入 Next.js，后端仍为 Django/DRF）

- 新建 `apps/next-web`，逐步把教学视图/回放迁到 Next（SSR/ISR）。
- 鉴权延续 Cookie；处理 CORS/CSRF（同父域、`CSRF_TRUSTED_ORIGINS`、`SameSite=Lax/Strict`）。
- Django 模板与 Next 可并行一段时间。

### Phase 2（逐步把 API 迁到 FastAPI）

- 新建 `apps/api-fastapi`，先迁**只读**端点，形成 v1（Django）/v2（FastAPI）双栈；
- FastAPI 使用公钥验证 JWT；用 SQLAlchemy/SQLModel 直连同库；
- 路由层按路径切流：`/api/v1/*` → Django，`/api/v2/*` → FastAPI；
- 用 **Schemathesis** 做契约回归；稳定后再迁写操作与 JWT 签发。

### Phase 3（实时与扩容）

- Channels 事件格式原样复用到 FastAPI WS/Socket.IO；
- Redis Pub/Sub 做房间广播；幂等、断线重连、顺序保证纳入协议；
- 先迁观战/广播类，再迁强一致的下注链路。

### 验收门（每阶段都要过）

- **契约一致**：v1/v2 OpenAPI 对齐、端到端回归绿灯；
- **可视化**：仪表盘能显示新增指标或性能改善；
- **文档**：ADR + 章节更新 + 自测题上线；
- **回滚**：反向切流或禁用新路由一键生效。

### 风险与缓解

- CORS/CSRF/Cookie 域：同父域、专用 API 域名；
- 数据漂移：迁移期间写操作只在一侧生效，或开启双写比对后下线；
- 技术债：每次迁移限定范围与期限，逾期回滚。

---

### 版本

- **v0.4（当前）**：新增 **回放持久化 PostgreSQL（可选切换）**、**教学视图注释位（hand annotations）**、文档站补充 v0.4 执行说明；维持 v0.3 的 API‑First/领域解耦/CI 双阈值。
- v0.3：脚手架 + OpenAPI 雏形 + `poker_core` 骨架 + CI 基线 + Demo 与教学视图（SQLite 持久化原型）+ ADR‑001/002 模板。

---

## 14) v0.3 执行清单（做中学）

> 目标：以**最小可运行 Demo**点亮端到端链路，并把工程化门槛固化为可视化与可度量的产物。

### 14.1 代码脚手架（仓库结构 + 本地环境）

- **产出**：`/apps`（web‑django/…），`/packages`（poker\_core/shared\_contracts），`/infra`（docker-compose、nginx.conf），基础健康检查页。
- **学习点**：模块化分层、依赖边界、Docker Compose 一键起服务。
- **可视化**：启动日志/健康页；（预留）仪表盘首屏占位。

### 14.2 OpenAPI 雏形（DRF + drf‑spectacular）

- **产出**：`/api/schema`、`/api/docs`（Swagger UI），版本化前缀 `/api/v1`。
- **初始端点**：
  - `POST /api/v1/table/deal`（可选 `seed`）
  - `GET /api/v1/replay/{id}`（返回最小回放 JSON）
- **学习点**：契约先行、Schema 设计、版本管理。

### 14.3 `packages/poker_core` 骨架（纯 Python 领域包）

- **产出**：发牌/状态最小实现、可复现随机（`seed`）、公共接口；测试覆盖率 **≥80%（仅该包）**。
- **学习点**：领域建模、纯函数/可测试性、与框架解耦。
- **元信息**：在回放写入 `seed`、RNG `algo/version`、`engine_commit`、`schema_version`、`ts`。

### 14.4 CI 基线（GitHub Actions：lint/测/覆盖率）

- **产出**：`.github/workflows/ci.yml`、`pyproject.toml`、`.pre-commit-config.yaml`、主干保护规则。
- **门槛**：全局覆盖率 **≥60%**；`poker_core` 子集 **≥80%**（一次测试、双阈值报告）。
- **学习点**：事件触发、runner、门禁、报告与失败调试。

### 14.5 文档站 & ADR 模板（Docs as Code）

- **产出**：Docusaurus/MkDocs 文档站上线；首批 ADR：
  - **ADR‑001** 覆盖率门槛策略（全局 60% / 核心 80%，随迭代抬升）。
  - **ADR‑002** 回放可复现信息规范（seed/algo/version/engine\_commit/schema\_version/ts）。
- **学习点**：Docs 与代码同源、决策留痕。

### 14.6 最小可运行 Demo（垂直切一刀）

- **内容**：
  1. `POST /api/v1/table/deal` 返回一手牌结果；
  2. `GET /api/v1/replay/{id}` 返回回放 JSON（先内存/文件 stub）；
  3. 极简页面按钮「Deal」+ 新手牌动效 + 结果 JSON 展示；
  4. 指标：`deals_total`、`req_latency_ms_p50/p95`、`error_rate`（简易统计）。
- **学习点**：垂直切片、端到端验证、价值可见化。

### 14.7 验收门（v0.3 必须全部通过）

1. `docker compose up` 起服务，`/api/docs` 可用；
2. `poker_core` 覆盖率 ≥80%，全局覆盖率 ≥60%；
3. CI（lint/测/覆盖率）全绿，主干受保护；
4. 文档站可访问，含《架构概览》《ADR‑001/002》《术语表 v0》；
5. 页面「Deal」可用，仪表盘计数/延迟可见。

> **不在 v0.3 范围**：持久化入库（可选 stub）、鉴权登录、实时 Channels、PokerKit 深度接入——这些将作为 v0.4+ 的扩展项按深度/广度路线推进。

---

## 15) 脚手架讲解（v0.3）

### 15.1 运行指南（本地最小化）

```bash
python -m venv .venv && source .venv/bin/activate
pip install -e '.[dev]'
cd apps/web-django
python manage.py migrate
python manage.py runserver
```

访问：`/`（Demo 页面）与 `/api/docs`（OpenAPI 文档）。

### 15.2 目录结构与边界

```
apps/
  web-django/           # Django + DRF + drf-spectacular（API-First）
    api/                # /table/deal, /replay/{id}, /metrics
    templates/demo.html # 极简页面（Deal 按钮 + 动效 + JSON 展示）
packages/
  poker_core/           # 纯 Python 领域心脏（可复现发牌、事件 steps）
  shared_contracts/     # OpenAPI/JSON Schema/事件枚举（占位）
.github/workflows/ci.yml# CI（全局60% & 核心80% 覆盖率双阈值）
pyproject.toml          # 工具链（pytest/ruff/black/isort/pre-commit）
```

**三大边界**：

- **API‑First**（DRF + OpenAPI）：合同先行，便于未来并行 FastAPI/Next。
- **领域解耦**（`packages/poker_core`）：纯函数、可测、可迁移。
- **工程可见**：CI 双阈值；`/api/v1/metrics` 提供 `deals_total`、`last_latency_ms`、`error_total`。

### 15.3 最小 Demo 组成

- **API**（v1）：
  - `POST /api/v1/table/deal`（入参：`seed?`、`num_players`；出参：`hand_id/seed/ts/engine_commit/schema_version/players[]`）
  - `GET /api/v1/replay/{id}`（回放 JSON：`hand_id/seed/engine_commit/schema_version/steps[]`）
  - `GET /api/v1/metrics`（KPI：`deals_total/last_latency_ms/error_total`）
- **前端**：`templates/demo.html`（Deal 按钮、轻微动效、KPI 刷新、结果与回放 JSON）。
- **领域**：`poker_core`（`deal_hand(seed, num_players)`；事件：`DECK_INIT`、`DEAL_HOLE`；可复现种子）。
- **测试**：`tests/test_poker_core_deal.py`（同 seed 必一致，玩家数与两张手牌校验）。

### 15.4 扩展路线

- **深度优先**：回放入库（Postgres + 迁移/索引）→ 教学视图 → 错误库雏形 → 契约测试 → 覆盖率抬升。
- **广度优先**：接入 PokerKit → JWT（RS256）→ `apps/next-web` 并行 → 事件 JSON（versioned）→ Channels + Redis。

---

## 16) 分支保护 & ADR 模板（v0.3）

### 16.1 GitHub 分支保护规则（建议）

1. Settings → Branches → Add rule：
   - Protect `main`；
   - Require status checks to pass：勾选 `CI / test`；
   - Require pull request reviews（可选，建议 ≥1）。
2. 在仓库根添加 `.pre-commit-config.yaml` 并执行：
   ```bash
   pip install pre-commit && pre-commit install
   ```
3. CI 采用**一次测试、双阈值**的覆盖率检查：全局 ≥60%，`packages/poker_core` ≥80%。

### 16.2 ADR 模板

> 目录：`/docs/adr/ADR-001.md`, `ADR-002.md`（文档站自动收录）

**ADR-001 覆盖率门槛策略（模板）**

```markdown
# ADR-001: 覆盖率门槛策略
- Status: Proposed (v0.3)
- Context: 领域包易测且关键；框架胶水层受框架影响较大。
- Decision:
  - Global coverage threshold: 60%（迭代抬升）
  - packages/poker_core: 80%（迭代目标 85–90%）
  - 单次执行 coverage，分别对全局与核心子集做 `--fail-under`
- Consequences:
  - 早期可控成本内保障质量；
  - 鼓励在可测区域（领域层）优先完善测试；
  - 后期逐步抬升全局阈值。
```

**ADR-002 回放可复现信息规范（模板）**

```markdown
# ADR-002: 回放可复现信息规范
- Status: Proposed (v0.3)
- Context: 教学/调试需要跨实现、跨版本稳定复现同一手牌。
- Decision:
  - 回放最小必填：`seed`、RNG `algo/version`、`engine_commit`、`schema_version`、`ts`
  - 事件 JSON 带 `version` 字段；重要字段变更递增版本
- Consequences:
  - 不同后端实现/版本可稳定重放；
  - 便于回溯问题与对比策略差异。
```

---

## 17) v0.4 执行清单（持久化 + 注释）

> 目标：让“教学对象（回放）”成为数据库一等公民，并在教学视图中呈现最小的策略/错误提示位。

### 17.1 交付物

- **PostgreSQL 持久化**：`DATABASE_URL` 存在则用 Postgres（`infra/docker-compose.yml` 一键起库），否则回退 SQLite。
- **教学注释位**：`packages/poker_core/analysis.py` 提供起步分类与注释（E001/N101/N102），API 返回 `annotations`。
- **文档**：`docs/execution_v0_4.md`（运行与验收说明）。

### 17.2 操作速查

```bash
# 起 Postgres（可选）
docker compose -f infra/docker-compose.yml up -d
cp .env.example .env
export $(cat .env | xargs)
# 迁移（切换到 Django 应用目录后执行）
cd apps/web-django && python manage.py migrate
```

访问：`/api/docs` 发牌拿 `hand_id` → `/teaching/hand/<hand_id>` 查看 **Players / Annotations / Timeline**。

### 17.3 验收门

1. 在 Postgres 模式下，`Replay` 记录成功入库；
2. 教学视图展示每位玩家的注释（WARN/INFO）；
3. 维持 v0.3 的 CI 双阈值（全局≥60%，`poker_core`≥80%）。

---

## 附录 A：自测题 & 讲解（CI 基线 × 最小垂直切片）

> 用于课堂外自测与公开教学材料；含参考讲解要点。

### A.1 试题

1. 覆盖率门槛 `--fail-under=60` 的意义是什么？应优先对哪个包设更高门槛，为什么？
2. 为什么坚持 **API‑First + OpenAPI**？这对切换到 FastAPI/Next 的最大好处是什么？
3. 垂直切片与“先做底层库再做 UI”相比，哪个更适合本项目？给出理由。
4. 为实现“可复现发牌”，回放需要写入哪些关键信息？
5. 说出一个**可见**指标（用户或仪表盘可见）与一个**不可见**质量指标（仅在 CI 可见）。

### A.2 参考讲解（要点）

1. 60% 以下直接失败；对 \*\*纯领域包 \*\*\`\` 设更高阈值（80–90%），因其纯函数、关键且易测；框架胶水层先 60% 起步。
2. 提前钉死“接口合同”，支持 **并行替换/共存**，还能做 **契约测试** 与 **客户端/类型代码生成**；削弱对具体后端/框架的耦合。
3. 选 **垂直切片**：更快形成端到端价值、可视化最强；避免“造库无演示”；利于持续反馈与风险可控。
4. 必填：`seed`、RNG `algo/version`、`engine_commit`、`schema_version`、`ts`（便于跨实现/跨版本稳定复现）。
5. 可见：`deals_total`、`req_latency_ms_p50/p95`、`error_rate`；不可见：测试总数、覆盖率%、lint/类型检查状态、CI 通过率。



---

## 附录 B：自测题 & 讲解（v0.4：持久化 × 教学注释）

### B.1 试题

1. 为什么我们用 `DATABASE_URL` 切换数据库后端？相比直接改 settings.py 有何工程优势？
2. 在发牌回放持久化中，`hand_id`、`seed`、`engine_commit` 各自的作用是什么？
3. 目前的注释位（E001/N101/N102）是如何从手牌推导出来的？它属于哪一层的责任？
4. 如果未来引入 PokerKit 或更复杂的策略引擎，`analysis.py` 应该如何演进以保持“防腐层”效果？
5. 请说出 v0.4 的两个**可见**指标（页面/接口可见）与一个**不可见**质量指标（CI 可见）。

### B.2 参考讲解（要点）

1. **配置即契约**：`DATABASE_URL` 让部署/切环境不改代码，遵守 12‑factor，便于 CI/CD 与多环境并行；settings.py 只保留解析逻辑。
2. `hand_id` = 回放主键与教学页路由锚；`seed` = 可复现随机的根；`engine_commit` = 引擎版本追溯与对比的依据。
3. 基于起手牌特征（对子/同花/连张差、牌力）给出简单规则；责任在 **领域分析层**（`poker_core/analysis.py`），UI 仅展示。
4. 让 `analysis.py` 成为 **适配/编排层**：从 PokerKit/策略服务拉取评估结果，转换为我们统一的注释结构（带 `code/severity/msg`），保持上层稳定。
5. 可见：`/api/v1/metrics` 的 `deals_total/last_latency_ms`、教学视图的 Annotations 数量/类型；不可见：覆盖率阈值通过情况、测试总数、lint 状态。

---

### B.3 你的作答 & 点评（节选）

**Q1**（`DATABASE_URL`）：✅ 观点正确。补充两点工程优势：

- 与容器/平台原生集成（Secrets/Env Vars），同一镜像可跑多环境；
- 变更可审计（改环境变量即可），避免“改代码→重发版”。

**Q2**（`seed` vs `hand_id` vs `engine_commit`）：

- `seed`：控制随机洗牌的输入；**相同种子 + 相同参数（如 ****\`\`****）** → 相同牌序与同一玩家拿到的手牌。
- `hand_id`：**这“一次对局实例”的唯一标识**（用于路由与数据库主键）。即便 `seed` 一样，**两次调用**也会生成不同的 `hand_id`（属于应用层，不由 `poker_core` 决定）。
- `engine_commit`：标记引擎实现的版本指纹；当我们修改了发牌算法/牌堆顺序/事件结构时，即使 `seed` 相同，结果也可能不同——用它来**精确还原“当时的引擎”**。

> 小结：`**\*\*\*\* 复现“随机性”；**`\*\* 标识“这一次”；**\`\`** 锁定“用的哪版引擎”。\*\*

**Q3**（注释位职责）：

- 来自 `analysis.py` 的**领域分析层**（Domain/Analysis），不是“教学 UI 层”。UI 只负责把注释放出来；分析逻辑在领域里，便于测试与复用。

**Q4**（PokerKit 适配）：✅ 思路正确。落地建议：

- 设计 `AnalysisProvider` 接口：`evaluate(hand_state)->[notes]`；
- PokerKit 作为其中一个 provider，适配为统一的 `{code,severity,msg}` 结构；
- 通过依赖注入/配置切换 provider，保持上层稳定。

**Q5**（可见 vs 不可见指标）：

- **可见指标（面向用户/演示/运维面板）**：在 UI 或公开接口可直接看到 → 例如 `/api/v1/metrics` 的 `deals_total/last_latency_ms`、教学视图里每手的 Annotations 数。**用途**：证明产品价值、发现体验问题。
- **不可见质量指标（面向工程质量/CI）**：需要读 CI/日志才能看到 → 例如 **覆盖率阈值**是否通过、**测试总数**、**lint/类型检查**、**契约回归绿灯**。**用途**：卡住回归与技术债，保障可持续交付。

> 记忆法：**“可见 = 给用户/演示看；不可见 = 给工程自我约束看。”** 两者一外一内，分别守住“价值被看见”和“质量不堆债”。

---

### B.4 你的作答 & 讲解（加码）

**Q1** 只改 `RANKS` 的顺序（例如从 `2..A`），不动其它逻辑，会影响同一 `seed` 的结果吗？为什么？\
**A**：**会**。因为 `seed → RNG → 洗牌索引 → 牌面` 的映射依赖**基础牌堆的序号**。`RANKS` 决定了我们构造“有序牌堆”的顺序；顺序一变，同一个 `seed` 生成的“第 i 张牌”对应到的**具体牌**就变了，从而影响整副牌与发牌结果。

**Q2** 用同一个 `seed`，把 `num_players` 从 2 改到 3，会发生什么变化？该不该视为“可复现”？\
**A**：**会变化**。因为“每名玩家分到第几张牌”的位置变了（发牌指针推进节奏不同），导致手牌/公共牌都不同。可复现性的定义应包含**全部控制变量**：`seed + num_players + algo/version + engine_commit`。因此改变 `num_players` **不应**视为“同场景的可复现”。

**Q3** 请为注释新增规则 **E002**（强烈警告）：相隔 ≥3 且非同花的弱牌；并写一个最小单测覆盖该规则。\
**解题指导（一步一步做）**：

1. **在领域分析层加入规则**（文件：`packages/poker_core/analysis.py`）

```python
# 片段：在文件顶部已有 RANKS = "23456789TJQKA" 时添加索引表
RANKS = "23456789TJQKA"
RANK_INDEX = {r: i for i, r in enumerate(RANKS)}

# 工具：两张牌 rank 差距（gap）
def _rank_gap(r1: str, r2: str) -> int:
    return abs(RANK_INDEX[r1] - RANK_INDEX[r2])

# 规则插入点：在你现有的 preflop 注释函数里追加（示例函数名）
# def preflop_annotations(hole: list[str]) -> list[dict]:
#   约定：hole 形如 ["7h", "2c"]，rank=首字符，suit=尾字符

def _e002_gap_offsuit_weak(hole: list[str]):
    a, b = hole
    r1, s1 = a[0], a[1]
    r2, s2 = b[0], b[1]
    offsuit = s1 != s2
    gap = _rank_gap(r1, r2)
    # “弱牌”阈值：两张都 < 'T'（即不含 T/J/Q/K/A），且非对子
    weak = (r1 in "23456789" and r2 in "23456789" and r1 != r2)
    if offsuit and gap >= 3 and weak:
        return {
            "code": "E002",
            "severity": "ERROR",
            "msg": f"Gap≥3 且非同花的弱牌：{a} {b}",
            "tags": ["preflop", "gap", "offsuit", "weak"]
        }
    return None

# 在你的主函数中合并：
# notes = []
# ...（其它规则）
# n = _e002_gap_offsuit_weak(hole)
# if n: notes.append(n)
# return notes
```

> 解释：
>
> - **gap≥3**：例如 `7x` vs `2x` 间隔 5；
> - **offsuit**：不同花色；
> - **弱牌**：两张都低于 `T` 且非对子（可根据教学需要再调阈值）。

2. **增加最小单测**（文件：`tests/test_analysis_e002.py`）

```python
import pytest

# 任选其一导入，视你的函数名而定：
from poker_core.analysis import preflop_annotations as _anno
# 或者： from poker_core.analysis import annotations_for_hole as _anno


def _codes(notes):
    # 兼容 dict 或对象的实现
    out = []
    for n in notes:
        if isinstance(n, dict):
            out.append(n.get("code"))
        else:
            out.append(getattr(n, "code", None))
    return set(out)


def test_e002_gap_offsuit_weak_triggers():
    # 典型弱牌：7h 2c → gap=5，非同花，且都< T
    notes = _anno(["7h", "2c"])
    assert "E002" in _codes(notes)


def test_e002_does_not_trigger_on_suited_or_small_gap():
    # 同花不触发
    assert "E002" not in _codes(_anno(["7h", "2h"]))
    # gap=2 不触发（如 97o）
    assert "E002" not in _codes(_anno(["9h", "7c"]))
    # 含高牌（如 A9o）不触发（按当前“弱牌”定义）
    assert "E002" not in _codes(_anno(["Ah", "9c"]))
```

3. **运行并验证**

```bash
pytest -k E002 -q
coverage report --include "packages/poker_core/*" --fail-under=80
```

4. **可选：阈值调参与文案**

- 如果你希望更严格/宽松，可把 `weak` 的阈值改为 `≤J` 或排除 `T9o`；
- 文案里可提示“入池成本高/反向隐含赔率差”，增强教学意义。



---

## 附录 C：Troubleshooting（Docker / Postgres / OpenAPI / 测试）

> 安装与切库的常见坑位与一键解决方案。

### C.1 `zsh: command not found: docker`

- **原因**：系统未安装 Docker CLI，或未启动后端（Desktop/Colima）。与 Python 虚拟环境无关。
- **解决 A：Docker Desktop（推荐）**
  ```bash
  brew install --cask docker
  # 安装后在“应用程序”里手动打开 Docker.app（首次需授权）
  docker --version
  docker compose version
  ```
- **解决 B：Colima 轻量方案**（不装 Desktop）
  ```bash
  brew install docker colima docker-compose
  colima start
  docker ps
  docker-compose -f infra/docker-compose.yml up -d  # 若 docker compose 不可用
  ```

### C.2 切到 Postgres 的标准步骤（与回退）

```bash
# 起容器并导出连接串
docker compose -f infra/docker-compose.yml up -d
cp .env.example .env
export $(cat .env | xargs)      # 导出 DATABASE_URL
# 迁移到目标库
cd apps/web-django && python manage.py migrate
```

- **回退 SQLite**：`unset DATABASE_URL` 后重新启动/测试即可。
- **本机装 PG（应急）**：
  ```bash
  brew install postgresql@15 && brew services start postgresql@15
  createdb poker
  psql postgres -c "CREATE USER poker WITH PASSWORD 'poker';"
  psql postgres -c "GRANT ALL PRIVILEGES ON DATABASE poker TO poker;"
  export DATABASE_URL=postgres://poker:poker@localhost:5432/poker
  cd apps/web-django && python manage.py migrate
  ```

### C.3 OpenAPI Schema 相关错误

- **现象**：`ValueError: Content-Type ... not "application/json"`。
- **原因**：`/api/schema/` 默认返回 `application/vnd.oai.openapi(+json)`。
- **做法**：在测试/脚本中显式声明 JSON，并自己解析：
  ```python
  r = c.get("/api/schema/", HTTP_ACCEPT="application/vnd.oai.openapi+json")
  import json; schema = json.loads(r.content)
  ```
- **404 with \*\*\*\***\`\`：格式名应为 `?format=json` 或使用 `Accept` 头。

### C.4 `ModuleNotFoundError: packages` / `api`

- **原因**：
  - 我们把可复用库安装为顶层包 \`\`，导入应为 `from poker_core...`；
  - 在 `tests/` 目录运行时，需把 `apps/web-django` 加入 `sys.path` 才能导入 `web/api`。
- **修正**：
  - 测试导入：`from poker_core.deal import deal_hand`；
  - `tests/conftest.py`：插入
    ```python
    import sys, os
    from pathlib import Path
    ROOT = Path(__file__).resolve().parents[1]
    sys.path.insert(0, str(ROOT / "apps" / "web-django"))
    os.environ.setdefault("DJANGO_SETTINGS_MODULE", "web.settings")
    ```

### C.5 `pip install -e '.[dev]'` 必须加引号

- **原因**：zsh/bash 会把 `[]` 当通配符；加引号或转义避免展开。
- **统一规范**：文档与 CI 已全部改为 `pip install -e '.[dev]'`。

### C.6 覆盖率为何未 100%？

- **解释**：未命中的多为“错误分支/回退路径/环境分支”（如 DB 回退、404、YAML 渲染）。
- **建议补法**：
  1. 加一条“清空内存回放后走 ORM 回退”的测试；
  2. 教学视图渲染 200/404；
  3. `analysis` 用参数化用例触发各分类（premium\_pair/speculative/...）。

### C.7 Nightly 与 PR 的测试分工

- **PR 必测**：领域单测 + API 合同 + 指标/持久化 + OpenAPI 基线 + 覆盖率双阈值（60%/80%）。
- **Nightly**：Postgres 容器、契约 fuzz（Schemathesis）、迁移健康检查、文档站构建、轻量压测。



---

### C.8 Colima 轻量派：踩坑记录 & 调试手册

> 背景：本机 8G 内存，选择 **Colima + docker-compose**（不用 Desktop）。

#### C.8.1 踩坑复盘

1. \`\`\*\* not found\*\*
   - **现象**：`error getting credentials ... docker-credential-desktop: executable file not found`。
   - **原因**：Docker CLI 读取了旧的 Desktop 凭据配置（`~/.docker/config.json`）。
   - **临时解法（推荐）**：为当前 shell 指定干净配置目录：
     ```bash
     mkdir -p ~/.config/colima-docker
     printf '{}
     ```

' > \~/.config/colima-docker/config.json export DOCKER\_CONFIG=\$HOME/.config/colima-docker \`\`\`

- **根治（可选）**：编辑 `~/.docker/config.json`，移除 `credsStore/credHelpers` 的 desktop 项。

2. \`\`

   - **现象**：`docker ps` 正常，但 `docker-compose up` 报错。
   - **原因**：`docker-compose` 不支持 Docker **context**，默认连系统 socket（`/var/run/docker.sock`），而 Colima 的 daemon 在 `~/.colima/default/docker.sock`。
   - **修复 A（有插件时）**：用新命令 `docker compose ...`（会复用当前 context）。
   - **修复 B（本次采用）**：显式指定 Colima 的 socket：
     ```bash
     export DOCKER_HOST=unix://$HOME/.colima/default/docker.sock
     docker-compose -f infra/docker-compose.yml up -d
     ```

3. \`\`\*\* is obsolete 警告\*\*

   - **原因/影响**：compose v2 开始忽略 `version` 字段，仅是提示，可忽略；后续我们会从文件中移除。

#### C.8.2 启停与环境切换（Colima + Postgres）

```bash
# 1) 启动 Colima（docker context 会指向 colima）
colima start
# 2) 选择 colima 上下文（若未自动切换）
docker context use colima
# 3) 仅在使用 docker-compose 时需要：指定 daemon socket
export DOCKER_HOST=unix://$HOME/.colima/default/docker.sock
# 4) 起 Postgres
docker-compose -f infra/docker-compose.yml up -d
# 5) 导出数据库连接串并迁移
cp .env.example .env && export $(cat .env | xargs)
cd apps/web-django && python manage.py migrate
```

- **回退 SQLite**：`unset DATABASE_URL`，重启服务/重跑测试。
- **一键别名（可加到 \~/.zshrc）**：
  ```bash
  alias dc='DOCKER_HOST=unix://$HOME/.colima/default/docker.sock docker-compose'
  ```

#### C.8.3 日常调试清单

```bash
# 查看容器 / 日志 / 进入容器
docker ps
docker logs -f infra-db-1
docker exec -it infra-db-1 bash

# 容器内连接 psql（默认用户/库 poker）
psql -U poker -d poker
\dt                      -- 列表
select count(*) from api_replay;

# 宿主机直接用 URL 连接
psql "$DATABASE_URL"     # 需要本机安装 psql（brew install libpq 或 postgresql@15）

# 备份 / 恢复（简版）
docker exec -t infra-db-1 pg_dump -U poker poker > backup.sql
psql "$DATABASE_URL" < backup.sql

# 重置数据库（危险：会删数据）
docker-compose -f infra/docker-compose.yml down -v
```

#### C.8.4 Colima 资源与维护

```bash
colima status
colima stop                 # 释放内存
colima start --memory 2     # 限制内存占用（单位 GB）
colima delete               # 删除虚拟机（会清掉所有容器与镜像）
```

#### C.8.5 PR 测试与本地验证（Postgres 模式）

```bash
# 确保容器在跑，且导出了 DATABASE_URL
pytest                       # 会在 Postgres 上创建测试库并跑用例
coverage run -m pytest && coverage report --fail-under=60
coverage report --include "packages/poker_core/*" --fail-under=80
```

> 说明：CI 仍以 SQLite 为主；需要在 CI 跑 PG 集成测试时，可在 job 前起服务并导出 `DATABASE_URL`，或使用服务容器。

---

### C.9 `psql "$DATABASE_URL"` 与 `docker logs -f infra-db-1` 速查

#### `psql "$DATABASE_URL"`

- **作用**：使用环境变量里的连接串一键连接数据库。
- **为何加引号**：避免 URL 中的特殊字符被 shell 误解析。
- **常用操作**：
  - `\dt` 查看表；`\d api_replay` 看表结构；\`select count(\*) from api\_replay;\` 查数量；`\q` 退出。
- 安装 psql：`brew ``install libpq` 并把二进制加入 PATH：
  ```bash
  echo 'export PATH="/opt/homebrew/opt/libpq/bin:$PATH"' >> ~/.zshrc && source ~/.zshrc
  ```
- **容器内执行**（无需在宿主机装 psql）：
  ```bash
  docker exec -it infra-db-1 psql -U poker -d poker
  ```

#### `docker logs -f infra-db-1`

- **作用**：实时查看 Postgres 容器日志（`-f` 持续追踪）。
- **常用变体**：`--tail 100`、`--since 10m`；退出 Ctrl+C。
- **Colima 注意**：若使用 `docker-compose`，记得先 `export DOCKER_HOST=unix://$HOME/.colima/default/docker.sock`。

---

### C.10 实时状态解读：你的 `infra-db-1`

> 以下根据你提供的日志逐行解读当前容器运行状态。

- **首次初始化成功**：日志里 `creating ... / running bootstrap / post-bootstrap initialization ... ok` 表明完成了**数据目录初始化（initdb）**。
- **临时 trust 提示**：`enabling "trust" authentication for local connections` 是官方镜像在初始化阶段的临时设置，用于完成引导；最终正常对外接口仍走口令验证，不影响安全性。
- **首启→停→正式启动**：看到一段 `server started` 后又 `server stopped`，这是**官方 entrypoint 的正常流程**：先短暂启动完成初始化（建库、应用配置），再以前台进程（PID 1）正式启动长期运行。
- **就绪可用**：`database system is ready to accept connections` 表示**已对外监听**（你也通过 `manage.py migrate` 验证了连接无误）。
- **定期 checkpoint**：`checkpoint starting: time/complete` 是 PostgreSQL 的**周期性检查点**，用于落盘与回收 WAL，非常正常。
- **一条 SQL 语法错误**：`ERROR: syntax error at or near "select" ...`，后面跟着两行 `select count(*) ...`，说明在 psql 里**连续输入了两条 SELECT 但缺少分号分隔**（或把两条贴到一行）。解决：每条语句末尾加分号，或一条一执行，例如：
  ```sql
  select count(*) from api_replay;
  -- 回车
  select count(*) from api_replay;
  ```
- **端口映射与网络**：你之前的 `docker ps` 显示 `0.0.0.0:5432->5432/tcp`，容器已映射到宿主机 5432 端口；`DATABASE_URL` 指向 `localhost:5432` 正确。
- **init 脚本提示**：`ignoring /docker-entrypoint-initdb.d/*` 表示该目录下没有初始化脚本（我们本项目没放），可忽略。

**结论**：容器已健康运行，数据库可正常接受连接；日志里的 ERROR 是一次性输入语句的格式问题，非系统性故障。接下来你可以：

1. 用 `psql "$DATABASE_URL"` 连库执行 `select count(*) from api_replay;`，确认迁移后的表中记录数；
2. 访问 `/api/docs` 调一次 `POST /api/v1/table/deal`，再查 `api_replay` 行数是否增加；
3. 如需节省内存，空闲时 `colima stop`，使用前 `colima start`。

---

### C.11 症状：`/api/docs` 发牌成功，但 Postgres 里 `api_replay` 仍为 0

> **现象**：主页 `Deals total` 在增（内存指标），但在 `psql` 里 `select count(*) from api_replay;` 仍为 0。
>
> **通常原因**：Django 进程是在 \*\*没有 \*\*\`\` 的环境里启动的，仍连接 **SQLite**；你后来导出变量/迁移到 Postgres 只影响“新启动的进程”，**老进程还在用 SQLite**。

#### 快速确认（A/B 对照）

A. **查 SQLite 是否在增长**：

```bash
sqlite3 apps/web-django/db.sqlite3 'select count(*) from api_replay;'
```

- 如果这里的计数在增加，就证实 Web 进程连接的是 SQLite。

B. **在运行中的 Django 里查看当前 DB 配置**（临时调试端点）：

```python
# apps/web-django/api/urls.py
from .views_debug import which_db  # 临时
path("debug/which-db", which_db)

# apps/web-django/api/views_debug.py（新增临时文件）
from rest_framework.decorators import api_view
from rest_framework.response import Response
from django.conf import settings

@api_view(["GET"])
def which_db(_request):
    cfg = settings.DATABASES["default"].copy()
    cfg.pop("PASSWORD", None)
    return Response(cfg)
```

- 访问 `GET /api/v1/debug/which-db`，若显示 `ENGINE: django.db.backends.sqlite3`，就说明该进程仍在用 SQLite。

> 注意：调试完成后可删除该端点文件与路由。

#### 正确启动顺序（确保 Web 连接 Postgres）

```bash
# 1) 起/确认 PG 容器
export DOCKER_HOST=unix://$HOME/.colima/default/docker.sock
docker-compose -f infra/docker-compose.yml up -d

# 2) 在**将要启动 Web 的同一个 shell**导出 DATABASE_URL
cd <repo-root>
export $(cat .env | xargs)      # 或者：env $(cat .env | xargs) <command>

# 3) 迁移到 PG（可选，已迁移过可跳过）
cd apps/web-django && python manage.py migrate

# 4) **重启** Web 进程（关键）：
# 停掉旧的 runserver（Ctrl+C），再在已导出 DATABASE_URL 的这个 shell 里启动
env $(cat ../../.env | xargs) python manage.py runserver
```

- 小技巧：用一次性前缀 `env $(cat .env | xargs) ...` 可以避免忘记导出。

#### 再次验证链路

1. `/api/docs` → `POST /api/v1/table/deal`（来两次）。
2. `psql "$DATABASE_URL" -c "select count(*) from api_replay;"` 应该 **+2**。
3. 如还不增：
   - 看 Django 控制台是否有 `Replay.objects.create` 的异常；
   - 临时给创建处加日志：
     ```python
     import logging; logger = logging.getLogger(__name__)
     ...
     try:
         Replay.objects.create(...)
     except Exception as e:
         logger.exception("replay-insert-failed: %s", e)
         pass
     ```
   - 或在 `which-db` 端点确认 `ENGINE`/`NAME`/`HOST` 确实指向 Postgres。

#### 背后知识点

- **进程环境固定性**：Django 进程启动时读取 `settings`，后续改环境变量**不会**影响已启动进程。
- **配置即契约**：使用 `DATABASE_URL` 切库时，要把“导出变量 → 启动服务”绑成一个动作（如 `env VAR=... command`）。
- **指标与数据源**：`Deals total` 来自内存指标 `METRICS`，与 DB 无关；验证持久化需要直接查数据库表。

---

## 18) 可观测性入门：指标语义（会话 vs 持久）与双数展示（v0.4.1）

> 把“运行时仪表（会话级）”与“业务真实（持久化）”分开展示，避免混淆；并提供最小实现方案。

### 18.1 概念与场景

- **会话指标（Session / Volatile）**：进程内存中的短期计数与延迟，例如 `METRICS['deals_total']`、`last_latency_ms`。**进程重启会清零**，多实例时各记各的。
- **持久指标（Persistent / Durable）**：落在数据库/数据仓库里的长期事实，例如 `Replay` 总数、近 24h 新增。**重启不丢失**，跨实例一致。

> 记忆法：**会话 = 现场仪表盘**（运行态）；**持久 = 账本**（业务态）。

### 18.2 改动目标

- `/api/v1/metrics` 同时返回：
  - `deals_total`（会话）；
  - `db_replays_total`（持久，取自 Postgres/SQLite）。
- 首页展示双数：`Session deals: X` 与 `Replays total: Y`。

### 18.3 后端改动（/metrics 双数返回）

文件：`apps/web-django/api/views_api.py`

```python
from rest_framework.decorators import api_view
from rest_framework.response import Response
from rest_framework import serializers
from drf_spectacular.utils import extend_schema, inline_serializer
from .state import METRICS

@extend_schema(responses={200: inline_serializer(name="Metrics", fields={
    "deals_total": serializers.IntegerField(),
    "last_latency_ms": serializers.IntegerField(allow_null=True),
    "error_total": serializers.IntegerField(),
    "db_replays_total": serializers.IntegerField(allow_null=True),  # 新增
})})
@api_view(["GET"])
def metrics_api(request):
    from .models import Replay
    payload = dict(METRICS)
    try:
        payload["db_replays_total"] = Replay.objects.count()
    except Exception:
        payload["db_replays_total"] = None
    return Response(payload)
```

> 说明：如果数据库暂不可用，`db_replays_total` 返回 `null`，前端显示 `-` 即可。

### 18.4 前端改动（首页双数展示）

文件：`apps/web-django/api/templates/demo.html`（或你的首页模板）

```html
<div id="metrics" class="metrics">
  <div>Session deals: <span id="session_deals">-</span></div>
  <div>Replays total: <span id="db_replays_total">-</span></div>
</div>
<script>
async function refreshMetrics() {
  const r = await fetch('/api/v1/metrics');
  const m = await r.json();
  document.getElementById('session_deals').textContent = m.deals_total ?? '-';
  document.getElementById('db_replays_total').textContent = (m.db_replays_total ?? '-');
}
refreshMetrics();
setInterval(refreshMetrics, 1500);
</script>
```

> 可选：把原 `Deals total` 的文案统一改为 `Session deals`，避免语义歧义。

### 18.5（可选）启动回填策略（把会话指标设为历史累计）

如果你希望 `Session deals` 在重启后也从数据库总数起步，可在 Django 启动时做一次回填：

```python
# apps/web-django/api/apps.py
from django.apps import AppConfig
class ApiConfig(AppConfig):
    name = 'api'
    def ready(self):
        from .state import METRICS
        try:
            from .models import Replay
            METRICS['deals_total'] = Replay.objects.count()
        except Exception:
            pass
```

> 注意：采用回填后，`deals_total` 语义变为“历史累计 + 本会话新增”。建议教学阶段先按 18.4 分开展示，语义更清晰。

### 18.6 最小测试建议（可选）

文件：`tests/test_metrics_and_persistence.py`

```python
from django.test import Client

def test_metrics_includes_db_total():
    c = Client()
    r = c.get('/api/v1/metrics')
    assert r.status_code == 200
    body = r.json()
    assert 'deals_total' in body
    assert 'db_replays_total' in body  # 新增字段
```

### 18.7 常见问题

- **为什么重启后 ****\`\`**** 归零？** 属于会话指标，重启即清空；设计如此。
- **多实例如何聚合 ****\`\`****？** 使用 Prometheus Counter 或 Redis 计数器；本章聚焦单实例教学。
- `\*\* 显示 `？\*\* 多半是 DB 不可用或未迁移；检查容器、连接串与迁移状态。

### 18.8 前端采集策略：温和轮询（Best Practice A）

> 降低后端压力与日志刷屏，同时保持指标即时性。

**要点**：

- **间隔**：5s；
- **可见性优化**：标签页隐藏时暂停，显示时恢复；
- **防重叠**：`AbortController` 取消上一轮未完成请求；
- **事件驱动加速**：用户点击关键操作（如 Deal）后立即刷新一次。

```html
<script>
let timer=null, ctrl=null;

function upd(id, val){
  const el=document.getElementById(id);
  const nv=(val??'-').toString();
  if(el && el.textContent!==nv){
    el.textContent=nv; el.classList.add('pulse');
    setTimeout(()=>el.classList.remove('pulse'),300);
  }
}

async function refreshMetrics(){
  try{
    if (ctrl) ctrl.abort();
    ctrl = new AbortController();
    const r = await fetch('/api/v1/metrics', {signal: ctrl.signal});
    const m = await r.json();
    upd('session_deals', m.deals_total);
    upd('db_replays_total', m.db_replays_total);
    upd('lat', m.last_latency_ms ?? '–');
    upd('errs', m.error_total);
  }catch(e){}
}
function startPolling(){ if(!timer) timer=setInterval(refreshMetrics, 5000); }
function stopPolling(){ if(timer){ clearInterval(timer); timer=null; } }

document.addEventListener('visibilitychange', ()=> document.hidden ? stopPolling() : (refreshMetrics(), startPolling()));

refreshMetrics();
startPolling();
</script>
```

> 进阶：Stage C 起可升级为 **SSE/WebSocket** 实时推送；届时本轮询逻辑可作为回退机制保留。

---

## 19) V1（MVP）框架定义：完整一手牌 → 多手对局（教学友好版）

> 目标：**能从发牌一路打到摊牌/弃牌结算，并连续开下一手**。强调可学性与可实现性：减少规则边界，先把“完整闭环”跑通。

### 19.1 规则边界（为教学降复杂）

- **人数**：仅 **Heads‑Up（2 人）**。
- **盲注**：SB=1，BB=2（固定，不动态调盲）。
- **筹码**：起始 100 BB，允许 **All‑in**。
- **下注模型**：**简化 No‑Limit**：
  - 每条街最多 **2 次加注**（raise cap=2），最小下注/加注额 = `max(BB, 当前需跟注额)`；
  - 允许超额加注到对手有效筹码上限（以 **有效筹码** 为界）。
- **流程**：Preflop（发两张）→ Flop（3）→ Turn（1）→ River（1）；各街按顺序下注；
- **胜负**：任一方弃牌或摊牌按牌力判定（引入 PokerKit 的评牌能力）；
- **分配**：只有两人，**无边池**问题（All‑in 时以较小有效筹码为上限，超出部分自动退回）。
- **座次轮转**：每手切换按钮（SB/BB 互换），下一手继续；
- **对局终止**：达到目标手数或有一方筹码 ≤ 0。

### 19.2 领域模型（最小可用）

- **Session**（对局）：`session_id`、配置（SB/BB/起始筹码/上限手数）、玩家（human/bot）、当前按钮位、手数计数、状态；
- **Hand**（一手）：`hand_id`、`session_id`、`seed`、按钮位、起始筹码快照、时间戳、**Steps（事件时间线）**、结算结果；
- **State**（运行态）：当前街（preflop/flop/turn/river）、行动方、需跟注额、已加注次数、底池、各方剩余筹码、公共牌/手牌；
- **Action**：`check/call/bet/raise/fold/allin`，可选 `amount`；
- **Outcome**：赢家/平分、筹码变动、下一手按钮位。

> **实现策略**：`packages/poker_core` 内实现 **纯函数状态机**：
>
> - `start_session(config) -> session`；
> - `start_hand(session, seed?) -> (hand, state, events[])`；
> - `legal_actions(state) -> set[str]`；
> - `apply_action(state, action) -> (state', events[])`；
> - `is_hand_over(state) -> bool`；
> - `settle(state) -> outcome`；
> - **评牌/胜者**：优先用 **PokerKit** 作为 evaluator（保持“库 + 关键自研”的路线），我们专注状态机与筹码账。

### 19.3 核心 API（在现有 v1 基础上扩展）

- `POST /api/v1/session/start` → 创建对局（人类 + 机器人），返回 `session_id`、初始 stacks、按钮位；
- `POST /api/v1/hand/start` → 参数：`session_id, seed?`；发盲注与底牌，返回 `hand_id` + 初始 `state`；
- `GET  /api/v1/hand/{hand_id}/state` → 查询当前状态（含合法动作 `legal_actions`）；
- `POST /api/v1/hand/{hand_id}/act` → 执行动作 `{actor, action, amount?}`，返回新 `state/steps`；若进入下一街，自动发公共牌；结束则返回 `outcome`；
- `GET  /api/v1/hand/{hand_id}/replay` → 完整时间线（兼容现有 `Replay`）；
- `GET  /api/v1/session/{session_id}/state` → 对局层状态（按钮位、当前手数、两侧筹码）；
- `POST /api/v1/suggest` → `{hand_id, actor}` 返回 **简单建议**（见 19.6）；
- `POST /api/v1/session/next` → 结束一手后开始下一手（或在 `act` 检测结束即自动触发 `next`）。

> **幂等性**：写操作支持 `Idempotency-Key`（请求头），避免重复提交导致双记账。

### 19.4 数据持久化与联动

- 继续沿用 `Replay(hand_id)` JSON **一等公民**（兼容 v0.4），扩展字段：
  - `session_id`、`button_pos`、`stacks_before/after`、`board`、`actions[]`（带街、序号、金额）、`outcome`；
- 新增 `Session` 表（最小 JSON）：`players[]/{id,name,is_bot}`, `config`, `stacks`, `button_pos`, `hand_counter`, `status`；
- **联动**：`seed` 存在 `Hand/Replay`；相同 `seed + 相同动作序列` ⇒ 可复现；`engine_commit/schema_version` 继续写入；
- **账本原则**：两人对局恒定总筹码守恒。可加一张 `chip_ledger`（可后置）做审计；MVP 先用 `stacks_after` 校验即可。

### 19.5 质量门槛（MVP 必过）

- **领域层覆盖率**：`poker_core` ≥ **85%**（状态转移/筹码结算/胜者判定）；
- **端到端**：
  1. 完整打一手（弃牌结束）；
  2. 完整打一手（摊牌结束）并校验赢家与筹码守恒；
  3. 连续两手（按钮位轮转、生效）；
- **不变量测试**：
  - `sum(stacks) + pot == constant` 在任意时刻成立；
  - `legal_actions` 与状态一致（无非法 check/raise）；
- **契约**：OpenAPI 更新 + `/api/docs` 可交互；
- **性能门**：单手 95% 延迟 < 100ms（本地）。

### 19.6 教学建议（最低可用规则）

- **Preflop 起手分类**（Premium/Pair/Suited Connector/Trash）→ 建议 `open/fold`；
- **位置与先后**：按钮位倾向更激进（同样牌力建议不同）；
- **跟注价位**：基于 **底池赔率** 与 **最小牌力阈值** 的二元决策（简化版，会在文档给表格）；
- **C‑bet 提示**：Flop 作为进攻者有 1 次标准 C‑bet 建议（量级统一成底池 1/2）；
- **危险板面**：同花/顺听面给 WARN 级提示。

> 机器人（可选开关）：使用同一套规则 + 随机扰动（ε‑greedy），便于模拟对局；接口位于 `AnalysisProvider(bot=True)`。

### 19.7 KPI 药丸（MVP 版）

- **Session deals**（会话）：本进程打了多少手；
- **Replays total**（持久）：累计保存的手数；
- **Stacks（P1/P2）**：两侧当前筹码（可做成两个小药丸）；
- **Avg pot**（本会话均值）；
- **Win rate**（近 N 手，简单占比）。

### 19.8 验收门（V1 必须看到的“可见价值”）

1. 在 UI 上，从 `Start Session` → `Deal` → 多个 `Act` → 结束 → `Next` 一气呵成；
2. 数据库里新增 `Session + Replay`，且 **筹码守恒**；
3. `/api/docs` 覆盖所有新端点，能点“Try it out”；
4. 自测题：解释一次结算细节（押注、底池、摊牌）并复盘建议为何如此。

### 19.9 你的 6 个问题（落地答复）

1. **核心 API 需要拓展什么？** 见 19.3；增：`session/start`、`hand/start`、`hand/act`、`session/state`、`suggest`、`session/next`。
2. **一手牌/seed 如何与库联动？** `Replay(hand_id)` 写入 `session_id/seed/engine_commit/schema_version/actions/outcome`；同 `seed + 动作序列` 可重放；`Session` 记录两侧 stacks 与按钮，手结束后更新。
3. **质量门槛**：领域覆盖 ≥85%；E2E 3 条必过；筹码守恒 property；OpenAPI 契约全；95p 延迟 <100ms（本地）。
4. **KPI 药丸**：新增 Stacks(P1/P2)、Avg pot、Win rate（近 N 手）；保留 Session deals / Replays total。
5. **注释规则**：起手分类、位置差异、底池赔率阈值、标准 C‑bet、危险面板 WARN。后续逐步细化到 Turn/River。
6. **单人对战要不要机器人？** 建议 **开**：同一套规则 + ε 随机。先可视化 + 可复现，再考虑更强策略。

### 19.10 下一步执行建议（v1‑alpha 迭代顺序）

1. **领域状态机雏形**（poker\_core）+ 评牌接入（PokerKit）；
2. 扩展 API：`session/start`、`hand/start`、`hand/act`、`state`；
3. UI：动作面板（按钮自动禁用非法动作）、时间线可视化、Stacks 药丸；
4. E2E 三条用例 + 筹码守恒 property；
5. `Replay`/`Session` JSON 入库；
6. （可选）机器人与 `suggest`。



---

## 20) PokerKit 集成策略（防腐层 / 不过度造轮子）

> 目标：**最大化复用 PokerKit 的成熟能力**（评牌/统计/符号记谱等），同时**把耦合限制在一个可替换的适配层**，保证我们自己的领域模型、事件与数据格式长期稳定。

### 20.1 复用与不复用的边界

- **直接复用（热路径）**：
  - **Hand Evaluation（评牌）**：作为牌力与赢家判定器；我们仅把“7 张牌集合”传入它，不把流程/下注交给它。
- **工具化复用（冷路径 / 离线）**：
  - **Statistical Analysis**：用于训练/报告/离线分析作业（Cron/Notebook），不放进请求热路径。
  - **Hand History 记谱**：作为**导入/导出插件**支持，不作为我们数据库的主格式。
  - **Game Simulation**：仅用于**机器人自测/回归对比**，不作为线上状态机实现。
- **不复用（我们自研）**：
  - **对局状态机**（发盲注/行动权/下注上限/跨街转移/筹码账本）；
  - **RNG/洗牌**（用我们自己的 `rng.py`，保证可复现与跨实现稳定性）。

### 20.2 防腐层设计（Anti‑Corruption Layer, ACL）

- 位置：`packages/poker_core/providers/pokerkit_adapter.py`
- 只暴露**领域中立**的接口，外部库类型**不得穿透边界**。

```text
interfaces.py
  └─ class HandEvaluator: evaluate7(cards7) -> EvalResult
pokerkit_adapter.py
  └─ class PokerKitEvaluator(HandEvaluator)
```

- 运行时通过配置/环境变量选择实现：`EVAL_PROVIDER=pokerkit`（默认），未来可切 `=builtin`。

### 20.3 决定性与可复现

- **只用我们的 RNG/洗牌**：`poker_core/rng.py` 产生牌序 → 传给 evaluator；**不调用** PokerKit 的 shuffle。
- 回放中写入：`seed/algo/version`、`engine_commit`、`schema_version`，保证**同 seed + 同动作**即可重放。

### 20.4 数据与契约

- 我们的**事件与回放 JSON**为**一等公民**（版本号 `v`）；PokerKit 记谱作为**转换插件**：
  - `to_pokerkit_notation(replay) -> str`
  - `from_pokerkit_notation(text) -> Replay`
- API/OpenAPI 只暴露我们的数据结构；任何第三方类型**不出现在契约里**。

### 20.5 版本管理与回归

- `pyproject.toml`：**固定精确版本** `pokerkit==x.y.z`；
- 新增契约/回归测试包：`tests/providers/test_pokerkit_adapter.py`：
  - **黄金用例**：一组已知 7 张牌 → 类别与强度断言；
  - **性质测试**（Hypothesis）：洗牌/重排不影响牌力；同牌面顺序不同结果一致；
  - **基准测试**：简单 micro-benchmark（可选）。
- Nightly 任务（可选）：对上游 minor 版本跑 smoke test，失败则不升级。

### 20.6 性能与容错

- 启用 **LRU 缓存**：key = 7 张牌的**规范化表示**（排序 + 序列化），复用常见场景的评牌结果；
- 将外部异常包一层我们的错误：`EvaluationError(code='pokerkit_error', ...)`；
- 设定评估超时（线程池/信号，仅用于离线任务），避免长尾阻塞。

### 20.7 分阶段接入（迁移/回滚友好）

1. **V1**：只接评牌（热路径）。
2. **V1.1**：加“手牌记谱转换”导入/导出（冷路径）。
3. **V1.2**：机器人/自测使用 `Game Simulation` 做离线对比，不进入线上状态机。
4. **回滚**：环境变量切到 `builtin` / 关闭插件；评牌失败则用**兜底提示**，不中断对局流程。

### 20.8 风险清单与缓解

- **API 变更**：固定版本 + 适配层；升级先走 Nightly。
- **性能瓶颈**：只用在评牌点；加缓存；需要时写 C 扩展/换实现而上层无感。
- **许可证**：遵循其 License；我们的回放与事件格式独立，避免“传染”。

> 结论：**库用得其所（评牌/工具），领域握在自己手里（状态机/事件/数据），用防腐层把两者隔开**。这既避免过度造轮子，也防止上游变动牵一发动全身。

---

### 20.9 当前进展快照（v0.4.x：状态机修正 & 测试）

> 你已对状态机做了多处关键修复；此处记录“做过什么”和“学到了什么”（不放具体代码）。

- **回合推进修正**：按街的 *check‑around* 进入下一街；有下注则以“跟到平”、或**max raise 次数用尽**后推进。
- **最小下注/加注**：`min = max(BB, to_call)`；加注幅度 ≥ 上一次有效加注幅度；
- **All‑in 到底 & 有效筹码**：允许把可用筹码一次推入，按有效筹码结算，避免超额；
- **No‑Limit 约束**：加入最小额与（教学友好）加注次数上限；
- **结算修正**：在 **showdown** 时一键结算，允许“对手弃牌即终止”；
- **测试通过**：端到端用例覆盖“全程 Checkdown 摊牌”“最小加注链路”“All‑in 推进”“非法动作拒绝”等；
- **不变量**：筹码守恒（`sum(stacks)+pot` 常数）、合法动作与状态一致性。

**工程要点**：

- *状态机* 与 *评牌器* 解耦（接口抽象）；
- 用 *端到端* 与 *性质测试* 保证升级后行为稳定；
- 回放 JSON 继续写入 `seed/engine_commit/schema_version`，可复现。

**测试代码**
```
from poker_core.state_hu import start_session, start_hand, legal_actions, apply_action, settle_if_needed
cfg = start_session(init_stack=200)
gs = start_hand(cfg, session_id="s1", hand_id="h1", button=0, seed=42)

def snap(gs):
    p0, p1 = gs.players
    return {
        "street": gs.street,
        "button": gs.button,       # 0=按钮(SB), 1=BB
        "to_act": gs.to_act,
        "board": gs.board,
        "pot": gs.pot,
        "invested": [p0.invested_street, p1.invested_street],
        "stacks": [p0.stack, p1.stack],
        "open_bet": gs.open_bet,
        "checks": gs.checks_in_round,
        "holes": [p0.hole, p1.hole],   # 👈 这里新增：双方底牌
        "legal": legal_actions(gs),
    }
```
gs = apply_action(gs, "check")
gs = apply_action(gs, "bet", amount=4)
gs = apply_action(gs, "raise", amount=4)
gs = apply_action(gs, "call")
gs = apply_action(gs, "allin")
gs = apply_action(gs, "fold")
gs = settle_if_needed(gs)
snap(gs)

```

---

## 21) 评牌接入实施清单（V1 起步）

> 目标：上线 **PokerKit 评牌** 作为赢家判定器；仅在 **showdown** 触发，其他流程仍由我们的状态机掌控。

### 21.1 准备与依赖

- `pyproject.toml` 固定版本：`pokerkit==0.6.3`；Python ≥ 3.11。
- 新增包：`packages/poker_core/providers/`（`interfaces.py`、`pokerkit_adapter.py`）。

### 21.2 适配层职责（不含具体代码）

- **输入**：7 张牌（两张手牌 + 5 张公共牌，字符串如 `As`, `Td`）。
- **输出**：
  - 可比较的 **strength**（用于 `>` `<` 判赢家）；
  - **best5**（最佳五张，用于教学展示）；
  - 可选 **category**（`straight_flush/full_house/...`）。
- **约束**：不暴露 PokerKit 类型；失败时抛我们自定义异常并降级处理。

### 21.3 调用点（只在摊牌）

- 在 `settle_if_needed()` / `showdown` 分支：对在局玩家分别求 `strength`，比较得出赢家；
- 回放/持久化：写入 `winner/index`、`best5`、`category`（可后置）。

### 21.4 测试与验收

- **黄金用例**：直顺同花 > 四条 > 葫芦 > 同花 > 顺子 > 三条 > 两对 > 一对 > 高牌；
- **对比测试**：两名玩家 + 指定公共牌，断言赢家索引、best5 正确；
- **性质测试**：同一 7 张牌不同顺序 → 结果一致；
- **性能门**：本地 95% 摊牌评估 < 1ms；热路径可加 LRU 缓存。

### 21.5 文档与开关

- 文档站新增《评牌接入指南》（本小节）；
- 环境开关：`EVAL_PROVIDER=pokerkit|builtin`，便于回滚；
- ADR‑003：外部库接入防腐层决策。

> 完成本清单后，即可把“赢家判定”切到 PokerKit；后续再接“牌谱导入/导出”“统计分析（离线）”。

